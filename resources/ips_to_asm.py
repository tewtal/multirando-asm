#!/usr/bin/env python3
"""
ips_to_asar_lorom.py

Convert Lunar IPS (.ips) -> Asar-friendly ASM using LoROM addressing (FastROM note).
Outputs "lorom" then "org $HHHHHH" / "db $AA,$BB,..." statements.

Usage:
    python ips_to_asar_lorom.py input.ips -o output.asm
"""
import argparse
import struct
from pathlib import Path
from typing import List, Tuple

# --- Helpers --------------------------------------------------------------

def read_be_uint24(b: bytes) -> int:
    """Read 3-byte big-endian unsigned int."""
    return (b[0] << 16) | (b[1] << 8) | b[2]

def pc_to_lorom_snes(pc: int) -> int:
    """
    Convert PC (file/ROM offset) to SNES LoROM address (ASAR-style).
    Formula (from ASAR / SMW-editor docs):
        SNES = ((PC << 1) & 0x7F0000) | (PC & 0x7FFF) | 0x808000
    Valid for PC < 0x400000.
    """
    if pc >= 0x400000:
        raise ValueError(f"PC offset 0x{pc:X} >= 0x400000; out of standard LoROM range")
    return ((pc << 1) & 0x7F0000) | (pc & 0x7FFF) | 0x808000

def hex_byte_list(bs: bytes) -> List[str]:
    return [f"${b:02X}" for b in bs]

def chunked(iterable, n):
    for i in range(0, len(iterable), n):
        yield iterable[i:i+n]

# --- IPS parsing ---------------------------------------------------------

def parse_ips(path: Path) -> List[Tuple[int, bytes]]:
    """
    Parse IPS file and return list of (pc_offset, data_bytes) hunks in order.
    RLE hunks are expanded to repeated bytes here.
    """
    data = path.read_bytes()
    pos = 0
    if len(data) < 8 or data[:5] != b"PATCH":
        raise ValueError("Not a valid IPS: missing 'PATCH' header")
    pos = 5
    hunks = []
    EOF_MARKER = b"EOF"

    while pos + 3 <= len(data):
        # If next three bytes are EOF, break
        if data[pos:pos+3] == EOF_MARKER:
            pos += 3
            break
        # read 3-byte offset
        if pos + 3 > len(data):
            raise ValueError("Unexpected end of IPS while reading offset")
        offset = read_be_uint24(data[pos:pos+3])
        pos += 3
        if pos + 2 > len(data):
            raise ValueError("Unexpected end of IPS while reading size")
        size = struct.unpack(">H", data[pos:pos+2])[0]
        pos += 2

        if size != 0:
            if pos + size > len(data):
                raise ValueError("Unexpected end of IPS data block")
            block = data[pos:pos+size]
            pos += size
            hunks.append((offset, block))
        else:
            # RLE block: next 2 bytes = run length (big-endian), then 1 byte value
            if pos + 3 > len(data):
                raise ValueError("Unexpected end of IPS while reading RLE")
            runlen = struct.unpack(">H", data[pos:pos+2])[0]
            val = data[pos+2]
            pos += 3
            block = bytes([val]) * runlen
            hunks.append((offset, block))

    # Some IPS implementations append a 3-byte "truncate" offset after EOF; ignore for now.
    return hunks

# --- Output formatting ---------------------------------------------------

def write_asar_asm(hunks: List[Tuple[int, bytes]], out_path: Path, max_per_line=16, include_lorom_directive=True):
    with out_path.open("w", newline="\n") as f:
        f.write("; Generated by ips_to_asar_lorom.py\n")
        if include_lorom_directive:
            f.write("lorom ; LoROM mapping (FastROM note: set FastROM in ROM header if required)\n\n")

        for (pc, block) in hunks:
            try:
                snes = pc_to_lorom_snes(pc)
            except ValueError as e:
                # fallback: write PC as comment and still write org with truncated address
                f.write(f"; WARNING: {e}\n")
                # still try mapping with masking, but user should verify
                snes = pc_to_lorom_snes(pc & 0x3FFFFF)

            f.write(f"org ${snes:06X}\n")
            # Write db lines: group bytes into max_per_line per "db" line
            bytes_hex = hex_byte_list(block)
            if not bytes_hex:
                f.write("; (empty block)\n\n")
                continue
            for chunk in chunked(bytes_hex, max_per_line):
                f.write(" db " + ",".join(chunk) + "\n")
            f.write("\n")

# --- CLI ----------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="Convert IPS -> Asar ASM (LoROM addresses)")
    parser.add_argument("ips", type=Path, help="input .ips file")
    parser.add_argument("-o", "--out", type=Path, default=Path("patch.asm"), help="output asm file")
    parser.add_argument("--no-lorom", action="store_true", help="don't write the 'lorom' directive at top")
    args = parser.parse_args()

    hunks = parse_ips(args.ips)
    write_asar_asm(hunks, args.out, include_lorom_directive=not args.no_lorom)
    print(f"Wrote {len(hunks)} hunks to {args.out}")

if __name__ == "__main__":
    main()
